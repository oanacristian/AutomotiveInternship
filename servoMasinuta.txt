/*
 * main.c              Copyright NXP 2016
 * Description:  Simple program to exercise ADC.
 * Use potentiometer on board to turn on RGB led
 * 2016 Jul 16 Osvaldo Romero: Initial version
 * 2016 Oct 31 SM: Clocks adjusted for 160 MHz SPLL
 * 2017 Jun 30 SM  Split adcResultInMv into separate global variables
 */

/*
 *
 * Modified by Ossian Adrian
 * 		This program maps the voltage from the microcontroller analog wheel to the led's.
 * 		In main() loop we have the readout from ADC. Depending on the voltage, we
 * give the variable state a value which will be used in the interrupt routine of the timer.
 * The next important part is the interrupt routine. We increment a variable each time a
 * interrupt happens and the expression parity % state should give us the ratio the led's are
 * turned off. If the state is 33, the led's are turned off all the time.
 *
 *
 *
 *
 *
 */

#include "S32K144.h" /* include peripheral declarations S32K144 */
#include "clocks_and_modes.h"
#include "ADC.h"
#define PTD15 15 /* RED LED*/
#define PTD16 16 /* GREEN LED*/
#define PTD0 0   /* BLUE LED */
#define PTD10 10
#define period 256

  uint32_t adcResultInMv_pot = 0;
  uint32_t adcResultInMv_Vrefsh = 0;

  unsigned short volatile parity = 0;
  unsigned short volatile state = 1;
  float volatile converted = 0.0;

 unsigned long get_clocks_in_milliseconds(unsigned int milliseconds)
 {
	 return 40000*milliseconds;
 }

 unsigned long get_clocks_in_microseconds(unsigned int microseconds)
  {
 	 return 40*microseconds;
  }


 void switch_on_blue_LED()
  {
  	PTD-> PCOR |= 1<<PTD0;/* Clear Output on port D0 (LED on) */
  }

 void switch_off_blue_LED()
  {
  	PTD-> PSOR |= 1<<PTD0; /* Set Output on port D0 (LED off) */
  }

 void toggle_blue_LED()
  {
  	PTD-> PTOR |= 1<<PTD0;
  }

 float map_int(int val,int pre_min, int pre_max, int post_min, int post_max)
 {
	return post_min + ((float)(post_max - post_min) / (float)(pre_max - pre_min)) * (val - pre_min);
 }


 void LPIT0_init (void) {
    PCC->PCCn[PCC_LPIT_INDEX] = PCC_PCCn_PCS(6);    /* Clock Src = 6 (SPLL2_DIV2_CLK)*/
    PCC->PCCn[PCC_LPIT_INDEX] |= PCC_PCCn_CGC_MASK; /* Enable clk to LPIT0 regs */
    LPIT0->MCR = 0x00000001;    /* DBG_EN-0: Timer chans stop in Debug mode */
                                /* DOZE_EN=0: Timer chans are stopped in DOZE mode */
                                /* SW_RST=0: SW reset does not reset timer chans, regs */
                             /* M_CEN=1: enable module clk (allows writing other LPIT0 regs)*/
    LPIT0->MIER = 0x00000001;   /* TIE0=1: Timer Interrupt Enabled fot Chan 0 */
    LPIT0->TMR[0].TVAL = get_clocks_in_microseconds(32);    /* Chan 0 Timeout period: 40M clocks */
    LPIT0->TMR[0].TCTRL = 0x00000001; /* T_EN=1: Timer channel is enabled */
                                /* CHAIN=0: channel chaining is disabled */
                                /* MODE=0: 32 periodic counter mode */
                                /* TSOT=0: Timer decrements immediately based on restart */
                                /* TSOI=0: Timer does not stop after timeout */
                                /* TROT=0 Timer will not reload on trigger */
                                /* TRG_SRC=0: External trigger soruce */
                                /* TRG_SEL=0: Timer chan 0 trigger source is selected*/
  }

void PORT_init (void) {
  PCC->PCCn[PCC_PORTD_INDEX ]|=PCC_PCCn_CGC_MASK;   /* Enable clock for PORTD */
  PORTD->PCR[PTD0]  =  0x00000100;  /* Port D0: MUX = GPIO */
  PORTD->PCR[PTD15] =  0x00000100;  /* Port D15: MUX = GPIO */
  PORTD->PCR[PTD16] =  0x00000100;  /* Port D16: MUX = GPIO */
  PORTD->PCR[PTD10] =  0x00000100;  /* Port D16: MUX = GPIO */

  PTD->PDDR |= 1<<PTD0;       	  /* Port D0:  Data Direction= output */
  PTD->PDDR |= 1<<PTD15;          /* Port D15: Data Direction= output */
  PTD->PDDR |= 1<<PTD16;          /* Port D16: Data Direction= output */
  PTD->PDDR |= 1<<PTD10;

  /* Enable clocks to peripherals (PORT modules) */
 PCC-> PCCn[PCC_PORTC_INDEX] = PCC_PCCn_CGC_MASK; /* Enable clock to PORT C */

}


void WDOG_disable (void){
  WDOG->CNT=0xD928C520;     /* Unlock watchdog */
  WDOG->TOVAL=0x0000FFFF;   /* Maximum timeout value */
  WDOG->CS = 0x00002100;    /* Disable watchdog */
}

void NVIC_init_IRQs (void) {
  S32_NVIC->ICPR[1] = 1 << (48 % 32);  /* IRQ48-LPIT0 ch0: clr any pending IRQ*/
  S32_NVIC->ISER[1] = 1 << (48 % 32);  /* IRQ48-LPIT0 ch0: enable IRQ */
  S32_NVIC->IP[48] = 0xA0;             /* IRQ48-LPIT0 ch0: priority 10 of 0-15*/
}

int main(void)
{
  WDOG_disable();        /* Disable WDOG*/
  SOSC_init_8MHz();      /* Initialize system oscillator for 8 MHz xtal */
  SPLL_init_160MHz();    /* Initialize SPLL to 160 MHz with 8 MHz SOSC */
  NormalRUNmode_80MHz(); /* Init clocks: 80 MHz sysclk & core, 40 MHz bus, 20 MHz flash */
  PORT_init();		     /* Init  port clocks and gpio outputs */
  ADC_init();            /* Init ADC resolution 12 bit*/
  NVIC_init_IRQs();        /* Enable desired interrupts and priorities */
  LPIT0_init();


  for(;;) {
    convertAdcChan(12);                   /* Convert Channel AD12 to pot on EVB */
    while(adc_complete()==0){}            /* Wait for conversion complete flag */
    adcResultInMv_pot = read_adc_chx();       /* Get channel's conversion results in mv */
    state = adcResultInMv_pot;
    converted = map_int(state, 0, 5000, 280, 565);

  }
}

void LPIT0_Ch0_IRQHandler (void) {
  LPIT0->MSR |= LPIT_MSR_TIF0_MASK; /* Clear LPIT0 timer flag 0 */
  LPIT0->MSR |= LPIT_MSR_TIF0_MASK; /* Clear LPIT0 timer flag 0 */
  parity+=10;
  if(parity<converted)
  {
	  PTD->PCOR |= 1<<PTD0 | 1<< PTD15 | 1<<PTD16;

	  PTD->PSOR |= 1<<PTD10; /* Turn on all LEDs */
  }

  else{
	  PTD->PSOR |= 1<<PTD0 | 1<< PTD15 | 1<<PTD16; /* Turn off all LEDs */
	  PTD->PCOR |= 1<<PTD10; /* Turn on all LEDs */
  }
  parity%=5000;

}
